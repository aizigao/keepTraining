# 一个数组中的数互不相同，求其中和为0的数对的个数。

a = [1, 23, 5, 233, 30, -2, 44, -1, -5, 0, 0]
n = len(a)

ans = 0
# for i in range(0, n):
#     for j in range(0, n):
#         if (a[i] + a[j] == 0):
#             ans = ans + 1
"""
来看看枚举的范围如何优化。由于题中没要求数对是有序的，答案就是有序的情况的两倍（考虑如果 (a, b) 是答案，那么 (b, a) 也是答案）。对于这种情况，只需统计人为要求有顺序之后的答案，最后再乘上  就好了。
"""

# for i in range(0, n):
#     for j in range(0, i):
#         if (a[i] + a[j] == 0):
#             ans = ans + 1
'''
两个数是否都一定要枚举出来呢？枚举其中一个数之后，题目的条件已经确定了其他的要素（另一个数）的条件，如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间了。较为进阶地，在数据范围允许的情况下，我们可以使用桶1记录遍历过的数。
'''

MAXN = 233
met = [False] * MAXN * 2
for i in range(0, n):
    if met[MAXN - a[i]]:
        ans = ans + 1
    met[a[i] + MAXN] = True

print(ans)